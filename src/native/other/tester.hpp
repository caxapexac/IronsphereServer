#ifndef LOGIC_TESTS_HPP
#define LOGIC_TESTS_HPP

#include <memory>
#include "ctime"
#include "../base/constants.hpp"
#include "../base/errors.hpp"
#include "../base/interfaces.hpp"
#include "../lobby/game_lobby.hpp"
#include "../structs/player.hpp"
#include "../structs/transform.hpp"
#include "../structs/vector2.hpp"
#include "../utils/map_builder.hpp"
#include "../utils/map_miles_builder.hpp"
#include "../utils/map_perlin_builder.hpp"

class tester {
private:
    tester () = default;

public:
    static int test_all ();
    static int test_lr1 ();
    static int test_lr2 ();
    static int test_lr3 ();
    static int test_lr4 ();
    static int test_lr5 ();
    static int test_lr6 ();
    static int test_lr7 ();
};

//TODO output string/count passed/exception with a problem
int tester::test_all () {
    int problems = 0;
    problems += test_lr1();
    problems += test_lr2();
    problems += test_lr3();
    problems += test_lr4();
    problems += test_lr5();
    problems += test_lr6();
    problems += test_lr7();
    return problems;
}

int tester::test_lr1 () {
    /// Init:
    srand(time(nullptr));
    json j;
    /// Test:
    /// Разработать и реализовать набор классов:
    /// - Класс игрового поля

    /// - Набор классов юнитов
    //TODO
    /// Игровое поле является контейнером для объектов представляющим прямоугольную сетку. Основные требования к классу игрового поля:
    /// - Создание поля произвольного размера

    /// - Контроль максимального количества объектов на поле
    // abstract_strategy::max_unit_count //TODO
    /// - Возможность добавления и удаления объектов на поле
    //player p = player(); //TODO no storage
    //player.add_unit(new unit); //TODO
    /// - Возможность копирования поля (включая объекты на нем)

    /// - Для хранения запрещается использовать контейнеры из stl

    /// Юнит является объектов, размещаемым на поля боя. Один юнит представляет собой отряд.
    /// Основные требования к классам юнитов:
    /// - Все юниты должны иметь как минимум один общий интерфейс
    /// - Реализованы 3 типа юнитов (например, пехота, лучники, конница)
    /// - Реализованы 2 вида юнитов для каждого типа(например, для пехоты могут быть созданы мечники и копейщики)
    /// - Юниты имеют характеристики, отражающие их основные атрибуты, такие как здоровье, броня, атака.
    /// - Юнит имеет возможность перемещаться по карте
    /// Баллы
    /// ~ Выполнены основные требования класса поле 3 балла
    /// ~ Выполнены основные требования классов юнитов 4 балла
    /// ~ Имеется 3+ демонстрационных примера 1 балл
    /// ~ Все методы класса сохраняют инвариант этого класса 2 балл
    /// ~ *Созданы конструкторы копирования и перемещения 2 балла
    /// ~ *Все методы принимают параметры оптимальным образом (то есть, отсутствует лишнее копирование объектов) 1 балл
    /// ~ *Для атрибутов юнитов созданы свои классы. Создавать их требуется, если это не противоречит логике. 2 балла
    /// ~ *Для создания юнитов используются паттерны “Абстрактный метод” / “Абстрактная фабрика” 3 баллов
    /// ~ *Создан итератор для поля 2 балла
    return 0;
}


int tester::test_lr2 () {
    /// Разработать и реализовать набор классов:
    /// - Класс базы
    /// - Набор классов ландшафта карты
    /// - Набор классов нейтральных объектов поля
    /// Класс базы должен отвечать за создание юнитов, а также учитывать юнитов, относящихся к текущей базе.
    /// - Основные требования к классу база:
    /// - База должна размещаться на поле
    /// - Методы для создания юнитов
    /// - Учет юнитов, и реакция на их уничтожение и создание
    /// - База должна обладать характеристиками такими, как здоровье, максимальное количество юнитов,
    ///   которые могут быть одновременно созданы на базе, и.т.д.
    /// Набор классов ландшафта определяют вид поля. Основные требования к классам ландшафта:
    /// - Должно быть создано минимум 3 типа ландшафта
    /// - Все классы ландшафта должны иметь как минимум один интерфейс
    /// - Ландшафт должен влиять на юнитов (например, возможно пройти по клетке с определенным ландшафтом
    ///   или запрет для атаки определенного типа юнитов)
    /// - На каждой клетке поля должен быть определенный тип ландшафта
    /// Набор классов нейтральных объектов представляют объекты, располагаемые на поле и с которыми могут взаимодействие юнитов. Основные требования к классам нейтральных объектов поля:
    /// - Создано не менее 4 типов нейтральных объектов
    /// - Взаимодействие юнитов с нейтральными объектами, должно быть реализовано в виде перегрузки операций
    /// - Классы нейтральных объектов должны иметь как минимум один общий интерфейс
    /// Баллы
    /// ~ Выполнены основные требования к классу база 2 балла
    /// ~ Выполнены основные требования к набору классов ландшафта 2 балла
    /// ~ Выполнены основные требования к набору классов нейтр. объектов 2 балла
    /// ~ Добавлено взаимодействие юнитов 1 балла
    /// ~ Имеется 3+ демонстрационных примера 1 балл
    /// ~ Взаимодействие через перегрузку операторов 2 балла
    /// ~ *Для хранения информации о юнитах в классе базы используется паттерн “Компоновщик” 2 балла
    /// ~ *Для наблюдения над юнитами в классе база используется паттерн “Наблюдатель” 2 балла
    /// ~ *Для взаимодействия ландшафта с юнитам используется паттерн “Прокси” 3 балла
    /// ~ *Для взаимодействия одного типа нейтрального объекта с разными типами юнитов используется паттерн “Стратегия” 3 балла
    return 0;
}
int tester::test_lr3 () {
    /// Разработать и реализовать набора классов для взаимодействия пользователя с юнитами и базой. Основные требования:
    /// - Должен быть реализован функционал управления юнитами
    /// - Должен быть реализован функционал управления базой
    /// Баллы
    /// ~ Выполнены все основные требования к взаимодействию 6 баллов
    /// ~ Добавлен функционал просмотра состояния базы 3 балла
    /// ~ Имеется 3+ демонстрационных примера 1 балл
    /// ~ *Реализован паттерн “Фасад” через который пользователь управляет программой 1 балл
    /// ~ *Объекты между собой взаимодействуют через паттерн “Посредника” 3 балла
    /// ~ *Для передачи команд используется паттерн “Команда” 3 балла
    /// ~ *Для приема команд от пользователя используется паттерн “Цепочка обязанностей” 3 балла
    return 0;
}
int tester::test_lr4 () {
    return 0;
}
int tester::test_lr5 () {
    return 0;
}
int tester::test_lr6 () {
    return 0;
}
int tester::test_lr7 () {
    return 0;
}


#endif //LOGIC_TESTS_HPP
